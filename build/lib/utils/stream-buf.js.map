{"version":3,"file":"stream-buf.js","names":["Stream","require","utils","StringBuf","StringChunk","constructor","data","encoding","_data","_encoding","length","toBuffer","copy","target","targetOffset","offset","_buffer","Buffer","from","StringBufChunk","_buf","BufferChunk","ReadWriteBuf","size","buffer","alloc","iRead","iWrite","buf","eod","full","read","undefined","write","chunk","Math","min","StreamBuf","options","bufSize","buffers","batch","corked","inPos","outPos","pipes","paused","inherits","Duplex","concat","map","rwBuf","_getWritableBuffer","last","push","_pipe","pipe","Promise","resolve","all","_writeToBuffers","inLen","callback","Function","nop","String","ArrayBuffer","Error","shift","process","nextTick","emit","cork","_flush","uncork","end","writeComplete","error","forEach","first","filter","Boolean","setEncoding","pause","resume","isPaused","destination","unpipe","unshift","wrap","module","exports"],"sources":["../../../lib/utils/stream-buf.js"],"sourcesContent":["/* eslint-disable max-classes-per-file */\r\nconst Stream = require('readable-stream');\r\n\r\nconst utils = require('./utils');\r\nconst StringBuf = require('./string-buf');\r\n\r\n// =============================================================================\r\n// data chunks - encapsulating incoming data\r\nclass StringChunk {\r\n  constructor(data, encoding) {\r\n    this._data = data;\r\n    this._encoding = encoding;\r\n  }\r\n\r\n  get length() {\r\n    return this.toBuffer().length;\r\n  }\r\n\r\n  // copy to target buffer\r\n  copy(target, targetOffset, offset, length) {\r\n    return this.toBuffer().copy(target, targetOffset, offset, length);\r\n  }\r\n\r\n  toBuffer() {\r\n    if (!this._buffer) {\r\n      this._buffer = Buffer.from(this._data, this._encoding);\r\n    }\r\n    return this._buffer;\r\n  }\r\n}\r\n\r\nclass StringBufChunk {\r\n  constructor(data) {\r\n    this._data = data;\r\n  }\r\n\r\n  get length() {\r\n    return this._data.length;\r\n  }\r\n\r\n  // copy to target buffer\r\n  copy(target, targetOffset, offset, length) {\r\n    // eslint-disable-next-line no-underscore-dangle\r\n    return this._data._buf.copy(target, targetOffset, offset, length);\r\n  }\r\n\r\n  toBuffer() {\r\n    return this._data.toBuffer();\r\n  }\r\n}\r\n\r\nclass BufferChunk {\r\n  constructor(data) {\r\n    this._data = data;\r\n  }\r\n\r\n  get length() {\r\n    return this._data.length;\r\n  }\r\n\r\n  // copy to target buffer\r\n  copy(target, targetOffset, offset, length) {\r\n    this._data.copy(target, targetOffset, offset, length);\r\n  }\r\n\r\n  toBuffer() {\r\n    return this._data;\r\n  }\r\n}\r\n\r\n// =============================================================================\r\n// ReadWriteBuf - a single buffer supporting simple read-write\r\nclass ReadWriteBuf {\r\n  constructor(size) {\r\n    this.size = size;\r\n    // the buffer\r\n    this.buffer = Buffer.alloc(size);\r\n    // read index\r\n    this.iRead = 0;\r\n    // write index\r\n    this.iWrite = 0;\r\n  }\r\n\r\n  toBuffer() {\r\n    if (this.iRead === 0 && this.iWrite === this.size) {\r\n      return this.buffer;\r\n    }\r\n\r\n    const buf = Buffer.alloc(this.iWrite - this.iRead);\r\n    this.buffer.copy(buf, 0, this.iRead, this.iWrite);\r\n    return buf;\r\n  }\r\n\r\n  get length() {\r\n    return this.iWrite - this.iRead;\r\n  }\r\n\r\n  get eod() {\r\n    return this.iRead === this.iWrite;\r\n  }\r\n\r\n  get full() {\r\n    return this.iWrite === this.size;\r\n  }\r\n\r\n  read(size) {\r\n    let buf;\r\n    // read size bytes from buffer and return buffer\r\n    if (size === 0) {\r\n      // special case - return null if no data requested\r\n      return null;\r\n    }\r\n\r\n    if (size === undefined || size >= this.length) {\r\n      // if no size specified or size is at least what we have then return all of the bytes\r\n      buf = this.toBuffer();\r\n      this.iRead = this.iWrite;\r\n      return buf;\r\n    }\r\n\r\n    // otherwise return a chunk\r\n    buf = Buffer.alloc(size);\r\n    this.buffer.copy(buf, 0, this.iRead, size);\r\n    this.iRead += size;\r\n    return buf;\r\n  }\r\n\r\n  write(chunk, offset, length) {\r\n    // write as many bytes from data from optional source offset\r\n    // and return number of bytes written\r\n    const size = Math.min(length, this.size - this.iWrite);\r\n    chunk.copy(this.buffer, this.iWrite, offset, offset + size);\r\n    this.iWrite += size;\r\n    return size;\r\n  }\r\n}\r\n\r\n// =============================================================================\r\n// StreamBuf - a multi-purpose read-write stream\r\n//  As MemBuf - write as much data as you like. Then call toBuffer() to consolidate\r\n//  As StreamHub - pipe to multiple writables\r\n//  As readable stream - feed data into the writable part and have some other code read from it.\r\n\r\n// Note: Not sure why but StreamBuf does not like JS \"class\" sugar. It fails the\r\n// integration tests\r\nconst StreamBuf = function(options) {\r\n  options = options || {};\r\n  this.bufSize = options.bufSize || 1024 * 1024;\r\n  this.buffers = [];\r\n\r\n  // batch mode fills a buffer completely before passing the data on\r\n  // to pipes or 'readable' event listeners\r\n  this.batch = options.batch || false;\r\n\r\n  this.corked = false;\r\n  // where in the current writable buffer we're up to\r\n  this.inPos = 0;\r\n\r\n  // where in the current readable buffer we've read up to\r\n  this.outPos = 0;\r\n\r\n  // consuming pipe streams go here\r\n  this.pipes = [];\r\n\r\n  // controls emit('data')\r\n  this.paused = false;\r\n\r\n  this.encoding = null;\r\n};\r\n\r\nutils.inherits(StreamBuf, Stream.Duplex, {\r\n  toBuffer() {\r\n    switch (this.buffers.length) {\r\n      case 0:\r\n        return null;\r\n      case 1:\r\n        return this.buffers[0].toBuffer();\r\n      default:\r\n        return Buffer.concat(this.buffers.map(rwBuf => rwBuf.toBuffer()));\r\n    }\r\n  },\r\n\r\n  // writable\r\n  // event drain - if write returns false (which it won't), indicates when safe to write again.\r\n  // finish - end() has been called\r\n  // pipe(src) - pipe() has been called on readable\r\n  // unpipe(src) - unpipe() has been called on readable\r\n  // error - duh\r\n\r\n  _getWritableBuffer() {\r\n    if (this.buffers.length) {\r\n      const last = this.buffers[this.buffers.length - 1];\r\n      if (!last.full) {\r\n        return last;\r\n      }\r\n    }\r\n    const buf = new ReadWriteBuf(this.bufSize);\r\n    this.buffers.push(buf);\r\n    return buf;\r\n  },\r\n\r\n  async _pipe(chunk) {\r\n    const write = function(pipe) {\r\n      return new Promise(resolve => {\r\n        pipe.write(chunk.toBuffer(), () => {\r\n          resolve();\r\n        });\r\n      });\r\n    };\r\n    await Promise.all(this.pipes.map(write));\r\n  },\r\n  _writeToBuffers(chunk) {\r\n    let inPos = 0;\r\n    const inLen = chunk.length;\r\n    while (inPos < inLen) {\r\n      // find writable buffer\r\n      const buffer = this._getWritableBuffer();\r\n\r\n      // write some data\r\n      inPos += buffer.write(chunk, inPos, inLen - inPos);\r\n    }\r\n  },\r\n  async write(data, encoding, callback) {\r\n    if (encoding instanceof Function) {\r\n      callback = encoding;\r\n      encoding = 'utf8';\r\n    }\r\n    callback = callback || utils.nop;\r\n\r\n    // encapsulate data into a chunk\r\n    let chunk;\r\n    if (data instanceof StringBuf) {\r\n      chunk = new StringBufChunk(data);\r\n    } else if (data instanceof Buffer) {\r\n      chunk = new BufferChunk(data);\r\n    } else if (typeof data === 'string' || data instanceof String || data instanceof ArrayBuffer) {\r\n      chunk = new StringChunk(data, encoding);\r\n    } else {\r\n      throw new Error('Chunk must be one of type String, Buffer or StringBuf.');\r\n    }\r\n\r\n    // now, do something with the chunk\r\n    if (this.pipes.length) {\r\n      if (this.batch) {\r\n        this._writeToBuffers(chunk);\r\n        while (!this.corked && this.buffers.length > 1) {\r\n          this._pipe(this.buffers.shift());\r\n        }\r\n      } else if (!this.corked) {\r\n        await this._pipe(chunk);\r\n        callback();\r\n      } else {\r\n        this._writeToBuffers(chunk);\r\n        process.nextTick(callback);\r\n      }\r\n    } else {\r\n      if (!this.paused) {\r\n        this.emit('data', chunk.toBuffer());\r\n      }\r\n\r\n      this._writeToBuffers(chunk);\r\n      this.emit('readable');\r\n    }\r\n\r\n    return true;\r\n  },\r\n  cork() {\r\n    this.corked = true;\r\n  },\r\n  _flush(/* destination */) {\r\n    // if we have comsumers...\r\n    if (this.pipes.length) {\r\n      // and there's stuff not written\r\n      while (this.buffers.length) {\r\n        this._pipe(this.buffers.shift());\r\n      }\r\n    }\r\n  },\r\n  uncork() {\r\n    this.corked = false;\r\n    this._flush();\r\n  },\r\n  end(chunk, encoding, callback) {\r\n    const writeComplete = error => {\r\n      if (error) {\r\n        callback(error);\r\n      } else {\r\n        this._flush();\r\n        this.pipes.forEach(pipe => {\r\n          pipe.end();\r\n        });\r\n        this.emit('finish');\r\n      }\r\n    };\r\n    if (chunk) {\r\n      this.write(chunk, encoding, writeComplete);\r\n    } else {\r\n      writeComplete();\r\n    }\r\n  },\r\n\r\n  // readable\r\n  // event readable - some data is now available\r\n  // event data - switch to flowing mode - feeds chunks to handler\r\n  // event end - no more data\r\n  // event close - optional, indicates upstream close\r\n  // event error - duh\r\n  read(size) {\r\n    let buffers;\r\n    // read min(buffer, size || infinity)\r\n    if (size) {\r\n      buffers = [];\r\n      while (size && this.buffers.length && !this.buffers[0].eod) {\r\n        const first = this.buffers[0];\r\n        const buffer = first.read(size);\r\n        size -= buffer.length;\r\n        buffers.push(buffer);\r\n        if (first.eod && first.full) {\r\n          this.buffers.shift();\r\n        }\r\n      }\r\n      return Buffer.concat(buffers);\r\n    }\r\n\r\n    buffers = this.buffers.map(buf => buf.toBuffer()).filter(Boolean);\r\n    this.buffers = [];\r\n    return Buffer.concat(buffers);\r\n  },\r\n  setEncoding(encoding) {\r\n    // causes stream.read or stream.on('data) to return strings of encoding instead of Buffer objects\r\n    this.encoding = encoding;\r\n  },\r\n  pause() {\r\n    this.paused = true;\r\n  },\r\n  resume() {\r\n    this.paused = false;\r\n  },\r\n  isPaused() {\r\n    return !!this.paused;\r\n  },\r\n  pipe(destination) {\r\n    // add destination to pipe list & write current buffer\r\n    this.pipes.push(destination);\r\n    if (!this.paused && this.buffers.length) {\r\n      this.end();\r\n    }\r\n  },\r\n  unpipe(destination) {\r\n    // remove destination from pipe list\r\n    this.pipes = this.pipes.filter(pipe => pipe !== destination);\r\n  },\r\n  unshift(/* chunk */) {\r\n    // some numpty has read some data that's not for them and they want to put it back!\r\n    // Might implement this some day\r\n    throw new Error('Not Implemented');\r\n  },\r\n  wrap(/* stream */) {\r\n    // not implemented\r\n    throw new Error('Not Implemented');\r\n  },\r\n});\r\n\r\nmodule.exports = StreamBuf;\r\n"],"mappings":"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","ignoreList":[]}